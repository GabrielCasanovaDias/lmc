# -*- coding: utf-8 -*-
"""Cópia de Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C1jsIfcQwMPDLq1CLpIu55bGBMFBpqFk
"""

# Exemplo de Aplicação da Lógica Booleana (baseado na Unidade 1, Seção 2 do livro "Lógica Computacional")
# para rodar no Google Colab

print("Simulação de Circuito de Votação do Comitê Multinacional\n")

# Variáveis para representar os votos dos membros do comitê:
# 1 = Voto a favor (ligado/verdadeiro) [6]
# 0 = Voto contra (desligado/falso) [6]

# A = Diretor Executivo
# B = Vice-Diretor Financeiro
# C = Vice-Diretor de Relações Institucionais

# O projeto só é aprovado se:
# 1. O Diretor Executivo (A) votar a favor (A = 1) [4]
# 2. E obtiver maioria (pelo menos 2 votos a favor no total, incluindo o de A) [4]
#    Isso significa que, se A for 1, o Vice-Diretor Financeiro (B) OU o Vice-Diretor de Relações Institucionais (C)
#    (ou ambos) também devem votar a favor.
#    Ou seja, a condição de maioria quando A é 1 é (B OU C).

# Definindo a função para simular a votação
def simular_votacao(voto_A, voto_B, voto_C):
    """
    Simula a votação do comitê e retorna se o projeto foi aprovado.
    A aprovação ocorre se o Diretor Executivo (A) votar 'sim' E houver maioria.
    A lógica utilizada é A AND (B OR C).
    """
    # Converte os valores numéricos (0 ou 1) para booleanos (False ou True) para aplicar a lógica Python
    A_aprovou = bool(voto_A)
    B_aprovou = bool(voto_B)
    C_aprovou = bool(voto_C)

    # A lógica de aprovação, conforme a regra da maioria e o voto do Diretor Executivo (A) [5, 7]
    # 'A' deve ser 'True' E ( 'B' deve ser 'True' OU 'C' deve ser 'True' )
    projeto_aprovado = A_aprovou and (B_aprovou or C_aprovou)

    # Traduzindo o resultado booleano para o estado da luz (1 para acesa, 0 para apagada) [6]
    luz_acesa = 1 if projeto_aprovado else 0

    return projeto_aprovado, luz_acesa

# Testando todas as combinações de votos (similar à Tabela 1.1 da fonte do livro [7])
combinacoes_voto = [
    (1, 1, 1), # A=Sim, B=Sim, C=Sim
    (1, 1, 0), # A=Sim, B=Sim, C=Não
    (1, 0, 1), # A=Sim, B=Não, C=Sim
    (1, 0, 0), # A=Sim, B=Não, C=Não (Não atinge maioria sem B ou C)
    (0, 1, 1), # A=Não, B=Sim, C=Sim (A não votou a favor)
    (0, 1, 0), # A=Não, B=Sim, C=Não (A não votou a favor)
    (0, 0, 1), # A=Não, B=Não, C=Sim (A não votou a favor)
    (0, 0, 0)  # A=Não, B=Não, C=Não
]

# Imprimindo o cabeçalho da tabela de resultados
print(f"{'Voto A':<8} {'Voto B':<8} {'Voto C':<8} {'Aprovado?':<12} {'Luz (1=Acesa)':<18}")
print("-" * 60)

# Iterando sobre as combinações e mostrando os resultados
for A, B, C in combinacoes_voto:
    aprovado_bool, luz_estado = simular_votacao(A, B, C)
    print(f"{A:<8} {B:<8} {C:<8} {str(aprovado_bool):<12} {luz_estado:<18}")

print("\n--- Explicação do Exemplo ---")
print("- Este exemplo demonstra a aplicação da **Álgebra Booleana**, que trata a lógica como um cálculo usando valores 0 (falso) e 1 (verdadeiro) [8].")
print("- A **lógica de aprovação** ('A AND (B OR C)') foi definida com base nas regras do problema do comitê, onde o Diretor Executivo (A) deve votar 'sim' E a proposta deve obter maioria (pelo menos 2 votos 'sim', incluindo o de A) [4, 7].")
print("- Os operadores 'and' e 'or' em Python correspondem aos conectivos lógicos **conjunção (Ù)** e **disjunção (Ú)**, respectivamente, que são fundamentais na lógica computacional [9].")
print("- A 'Aula 1' destaca o Período Booleano como a base para as lógicas usadas nas linguagens de programação modernas [1, 2], e este exemplo prático ilustra como esses conceitos se traduzem em código.")
print("- A simulação mostra como diferentes combinações de entradas (votos) resultam em uma saída lógica (projeto aprovado ou não), refletindo uma **Tabela Verdade** [5, 7].")